<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>manual</title>
<style type="text/css">/*...*/</style>
</head>
<body>
<h1>Definitions</h1><p><em>"clock period" or "clock cycle"</em><br/>Time during which pipeline stages compute outputs from inputs.</p><p><em>"master latch"</em><br/>Output from a pipeline stage, input to a pipeline register.</p><p><em>"slave latch"</em><br/>Input to a pipeline stage, output to a pipeline register.</p><p><em>"clock edge" or "clock boundary"</em><br/>An event when data coming into all pipeline registers (master latch) is transferred to their outputs (slave latch). This is when the whole CPU advances in time from one clock period to the next.</p><h1>Class hierarchy</h1><p>Below is documentation of the most important methods for each class type. To see documentation on more methods provided by these classes, look at the interface classes in the utilitytypes directory.</p><h2>Component</h2><p><code>class ComponentBase implements IComponent</code></p><p>Any object in the system that can have a name and a parent Module. Most other classes in this system subclass ComponentBase.</p><h2>Pipeline Register</h2><p><code>class PipelineRegister extends ComponentBase implements IPipeReg</code></p><p>Pipeline registers pass data between pipeline stages when advancing from one clock period to the next. Output from a preceding pipeline stage is input to a pipeline register's master Latch. Output from a pipeline register's slave latch is input to the succeeding pipeline stage.</p><p>The pipeline register's master latch is filled with data from the preceding pipeline stage. When advancing to the next clock period (by using the 1advanceClock()` method), the pipeline register transfers master latch contents to the slave latch. This makes the data available for reading by the succeeding pipeline stage.</p><h3>Important methods:</h3><p><strong><code>Latch read()</code></strong><br/>For a pipeline register that is input to a pipeline stage read the contents of the slave Latch. Note that this does not dequeue, invalidate, or consume the slave latch. This method allows you to access the input data and evaluate whether or not it can be processed at this time.</p><p><strong><code>Latch newLatch()</code></strong><br/>Allocate an empty Latch object to be filled with the output from a pipeline stage.</p><p><strong><code>boolean canAcceptWork()</code></strong><br/>Returns true when the pipeline register will be able to transfer data written to the master match to its slave latch on the next clock boundary. Returns false when a stall condition in the next stage is blocking such a transfer.</p><h2>Latch</h2><p><code>class Latch extends PropertiesContainer</code></p><p>A data container used to communicate an instruction and other information between pipeline stages on clock boundaries. Latches contain a pre-defined field to hold an Instruction and extend PropertiesContainer so that instructions and other arbitrary data can be passed between pipeline stages on clock boundaries.</p><p>A pipeline register slave latch is retrieved as input to a pipeline stage by calling the <code>read()</code> method on an input pipeline register. </p><h3>Important methods:</h3><p><strong><code>boolean canAcceptWork()</code></strong><br/>For an output Latch produced by calling <code>PipelineRegister.newLatch()</code>, this method returns true when the pipeline register will be able to transfer data written to the master match to its slave latch on the next clock boundary. This yields the same result as calling canAcceptWork on the pipeline register that this Latch was allocated from.</p><p><strong><code>void write()</code></strong><br/>For a pipeline register that takes output from a pipeline stage, write the contents of this newly allocated and filled Latch object to the master latch of the pipeline register.</p><p><strong><code>void consume()</code></strong><br/>For an input Latch provided by calling <code>PipelineRegister.read()</code>, this method informs the pipeline register that its slave latch contents have been processed and can be freed (dequeued, invalidated).</p><p><em>Important:</em> Not calling this method implicitly causes a pipeline stall condition. It is important to explicitly consume input in order that new input can be received on the next cycle.</p><p>This method is equivalent to calling <code>consumeSlave()</code> on the pipeline register that produced this latch.</p><p><strong><code>InstructionBase getInstruction()</code></strong><br/>Returns the instruction field in this Latch. </p><p><strong><code>void setInstruction(InstructionBase ins)</code></strong><br/>Sets the instruction field in this Latch.</p><p><strong><code>boolean hasResultValue()</code></strong><br/>Returns true if this Latch contains a result value.</p><p><strong><code>boolean isResultFloat()</code></strong><br/>Returns true if the result came from a floating point computation.</p><p><strong><code>int getResultRegNum()</code></strong><br/>If this latch contains a result value, return the architectural or physical register number. Otherwise, return -1.</p><p><strong><code>int getResultValue()</code></strong><br/>Returns result value in integer form.</p><p><strong><code>float getResultValueAsFloat()</code></strong><br/>Returns result value reinterpreted as a float.</p><p><strong><code>void setResultValue(int value)</code></strong><br/>Sets an integer result value in the Latch.</p><p><strong><code>void setResultFloatValue(int value)</code></strong><br/>Sets a float result value (stored in an int) in the Latch.</p><p><strong><code>void setResultFloatValue(float value)</code></strong><br/>Sets a float result value in the latch. The bits of the float value are internally stored in an int.</p><p><strong><code>void setResultValue(int value, boolean isfloat)</code></strong><br/>Set a result value (encoded in an int), optionally marking it as an encoded float.</p><p><strong><code>boolean isNull()</code></strong><br/>Return true if the Latch itself is null or the instruction field in it is null.</p><p><strong><code>void copyAllPropertiesFrom(Latch source)</code></strong><br/>Copies all properties (excluding the instruction) from another latch. Useful for copying all properties from an input latch to an output latch.</p><p><strong><code>void copyParentPropertiesFrom(Latch source)</code></strong><br/>The pipeline register that this Latch belongs to (its parent) can be given a list of property names (using <code>PipelineRegister.setPropertiesList(Set&lt;String&gt; pl)</code>). This method copies only those properties from the specified source to this Latch.</p><p><strong><code>Latch duplicate()</code></strong><br/>Makes a deep copy of of this Latch. This is useful if you want to modify the contents of the Latch without affecting the original.<br/>Note that posted forwarding requires that the original input Latch be modified.</p><h2>Pipeline Stage</h2><p><code>abstract class PipelineStageBase extends ComponentBase implements IPipeStage</code></p><p><code>PipelineStageBase</code> is an abstract class that must be subclassed by every pipeline stage in your processor architecture.</p><h3>Important methods:</h3><p><strong><code>Latch readInput(int input_num)</code></strong><br/>Pipeline stages may have multiple inputs. This reads the slave latch of the specified input pipeline register.</p><p><strong><code>List&lt;IPipeReg&gt; getInputRegisters()</code></strong><br/>Return the list of all input pipeline registers.</p><p><strong><code>int numInputRegisters()</code></strong><br/>Returns the number of input pipeline registers.</p><p><strong><code>int lookupInput(String name)</code></strong><br/>Look up the index of an input register by its name.</p><p><strong><code>Latch newOutput(int out_num)</code></strong><br/>Pipeline stages may have multiple outputs. This allocates a new latch for the specified output pipeline register.</p><p><strong><code>boolean outputCanAcceptWork(int out_num)</code></strong><br/>Returns true if the specified output pipeline register can accept new work.</p><p><strong><code>List&lt;IPipeReg&gt; getOutputRegisters()</code></strong><br/>Return the list of all output pipeline registers.</p><p><strong><code>int numOutputRegisters()</code></strong><br/>Returns the number of output pipeline registers.</p><p><strong><code>void registerFileLookup(Latch input)</code></strong><br/>Tries to look up all source register operands from the register file. Only registers marked valid are retrieved. This is used by a pipeline stage authorized to access the register file, like Decode. The argument must be a duplicate of the original input latch to the pipeline stage.</p><p><strong><code>void forwardingSearch(Latch input)</code></strong><br/>At initialization time, a list of forwarding source is provided to the processor core. This method searches the pipeline registers named in that list for forwarding opportunities. </p><p>Register values that are already valid are retrieved immediately and <code>setValue</code> is called on matching operands.</p><p>Register values that will be available on the next cycle are posted for forwarding to the next stage by setting <code>forward0</code>, <code>forward1</code>, and/or <code>forward2</code> properties on the latch. These properties can be copied to the output latch so that the next stage can satisfy its dependencies on the next cycle by calling <code>doPostedFowarding</code>.</p><p><strong>Important:</strong> Call this method on a duplicate of the original input latch. </p><p><strong><code>void doPostedForwarding(Latch input)</code></strong><br/>A pipeline stage that receives input with properties named <code>forward0</code>, <code>forward1</code>, and/or <code>forward2</code> can call this method to retrieve operand values from the pipeline registers whose names are values of those properties.</p><p><strong>Important: Do not</strong> call this on a duplicate of the input latch. The original latch must be updated so that forwarded values are retained in the in the input latch even under a stall condition.</p><p><strong><code>void setResourceWait(String reason_stalled)</code></strong><br/>Indicate that this pipeline stage is stalled waiting on an external resource (e.g. register to become valid), providing a string that specifies what the stage is waiting on. To rescind a stall condition, call this method with null as the argument.</p><p><strong><code>void setActivity(String act)</code></strong><br/>Set the string that specifies the primary activity of this pipeline stage, i.e. the instruction it is executing. Usually, this is automatic, but sometimes it has to be set explicitly.</p><p><strong><code>void addStatusWord(String word)</code></strong><br/>Add a string to the list of status keywords, indicating the state of this pipeline stage.</p><h2>Module</h2><p><code>abstract class ModuleBase extends ComponentBase implements IModule</code></p><p>A Module is a type of Component that is able to contain pipeline stages, pipeline registers, child functional units, and properties. ModuleBase is abstract and must be subclassed for each module in your design; however, most modules you create will be subclasses of FunctionalUnitBase, which itself is a subclass of ModuleBase.</p><h3>Important methods:</h3><p><strong><code>IProperties getProperties()</code></strong><br/>Return a reference to the PropertiesContainer that belongs to this module.</p><p><strong><code>IGlobals getGlobals()</code></strong><br/>Return a reference to the global PropertiesContainer that is contained in the top-level (CpuCore) module.</p><p><strong><code>void createPipelineRegisters()</code></strong><br/>This method is automatically called by the constructor and is where you add code that instantiates all pipeline registers in this module (typically by calling <code>createPipeReg(String name)</code>. </p><p><strong><code>void createPipelineStages()</code></strong><br/>This method is automatically called by the constructor and is where you add code that instantiates all pipeline stages in this module. Create new instances of each of your pipeline stages and use <code>addPipeStage()</code> to add them.</p><p><strong><code>void createChildModules()</code></strong><br/>This method is automatically called by the constructor and is where you add code that instantiates all child <code>FunctionalUnit</code> objects. Create new instances of each child unit and use <code>addChildUnit()</code> to add them.</p><p><strong><code>void createConnections()</code></strong><br/>This method is automatically called by the constructor and is where you add code that connects all pipeline registers, pipeline stages, and child functional units. There is a set of <code>connect()</code> methods provided for making connections.</p><p><strong><code>void specifyForwardingSources()</code></strong><br/>This method is automatically called by the constructor and is where you add code that indicates which pipeline registers are forwarding sources. Call the <code>addForwardingSource()</code> for each forwarding source.</p><p><strong><code>void addPipeStage(IPipeStage stage)</code></strong><br/>Call this to add to this Module a newly created pipeline stage object (which must be a subclass of PipelineStageBase or implement the IPipeStage interface).</p><p><strong><code>void addPipeReg(IPipeReg reg)</code></strong><br/>Call this to add to this Module a newly created pipeline register object; however, most pipeline registers will be created by calling <code>createPipeReg</code> instead.</p><p><strong><code>void addChildUnit(IFunctionalUnit unit)</code></strong><br/>Call this to add to this Module a newly created child functional unit object (which must be a subclass of FunctionalUnitBase or implement the IFunctionalUnit interface). </p><p><strong><code>void connect(String source_name, String target_name)</code></strong><br/>Specified by names, connect a pipeline stage to a succeeding pipeline register or a pipeline register to its succeeding pipeline stage.</p><p><strong><code>void connect(String stage1, String reg, String stage2)</code></strong><br/>Specified by names, connect two pipeline stages through a pipeline register.</p><p><strong><code>void createPipeReg(String name)</code></strong><br/>Create a new pipeline register with no default property names and add it to this module.</p><p><strong><code>void createPipeReg(String name, String[] props)</code></strong><br/>Create a new pipeline register with a specified array of property names and add it to this module. This list of property names is used when the <code>copyParentPropertiesFrom</code> method is called on new output latches created by this pipeline register.</p><p><strong><code>void addForwardingSource(String name)</code></strong><br/>Call this with the name of a pipeline register to specify that register as a forwarding source.</p><p><strong><code>void addStageAlias(String real_name, String alias_name)</code></strong><br/>Create an alias for a specified pipeline stage. This is particularly useful when making a pipeline stage appear as an input stage higher up in the module hierarchy. </p><p>For instance, consider functional unit "A" that has a child functional unit "B" with a pipeline stage "Compute". In <code>A.createConnections</code>, call <code>addStageAlias(&quot;B.Compute&quot;, &quot;in:Compute&quot;)</code>. This will make "A.B.Compute" appear as a stage in "A", and using the "in:" prefix (or just the name "in") will also make the stage automatically findable as an input to functional unit A.</p><p><strong><code>void addRegAlias(String real_name, String alias_name)</code></strong><br/>Create an alias for a specified pipeline register. This is particularly useful when making a pipeline register appear as an output register higher up in the module hierarchy. </p><p>For instance, consider functional unit "Example" that has a child functional unit "Delay" with a pipeline register "out". In 'Example.createConnections<code>, call</code>addRegAlias("Delay.out", "out")`. This will make "Example.Delay.out" appear as a register in "Example," and using the name "out" (or the prefix "out:") will also make the register automatically findable as an output from functional unit Example.</p><h2>FunctionalUnit</h2><p><code>abstract class FunctionalUnitBase extends ModuleBase implements IFunctionalUnit</code></p><p>A functional unit is a type of Module that adds inputs and outputs to the the Module so that the the module can be added as a child unit to another module and connected into the processor pipeline.</p><p>FunctionalUnitBase is abstract, and all of the methods you must implement are explained above under Module.</p><h3>Important methods:</h3><p><strong><code>IPipeStage getInputPipeStage(String name)</code></strong><br/>Given a name, look up an individual functional unit input pipeline stage. Only stages with the name "in" or that start with the prefix "in:" are considered valid functional unit inputs.</p><p><strong><code>Map&lt;String,IPipeStage&gt; getInputPipeStages()</code></strong><br/>Returns all input pipeline stages for this functional unit. The returned map will contain only local pipeline stages and aliases whose names are "in" or start with "in:". </p><p><strong><code>IPipeReg getOutputPipeReg(String name)</code></strong><br/>Given a name, look up an individual functional unit output pipeline register. Only registers with the name "out" or that start with the prefix "out:" are considered valid functional unit outputs.</p><p><strong><code>Map&lt;String,IPipeReg&gt; getOutputPipeRegs()</code></strong><br/>Returns all output pipeline registers for this functional unit. The returned map will contain only local pipeline registers and aliases whose names are "out" or start with "out:". </p><h2>CpuCore</h2><p><code>abstract class CpuCore extends ModuleBase implements ICpuCore</code></p><p>A CPU core is a type of Module that represents the top level of the CPU module hierarchy. CpuCore is abstract, and most of the methods you must implement are explained above under Module.</p><h3>Important methods:</h3><p><strong><code>IPipeStage getFirstStage()</code></strong><br/>This is called automatically by the constructor and passed to the code that automatically sorts pipeline stages into optimal evaluation order and print order.</p><p><strong><code>void printHierarchy()</code></strong><br/>Prints out the module hierarchy, specifically which registers are inputs and outputs for each pipeline stage. Full hierarchical names are printed (along with aliases), which makes this a good reference when trying to figure out the full name of a component.</p><h2>PropertiesContainer</h2><p>Genetic container of properties of various data types, indexed by String name. This is the base class for global data and for pipeline latches. This is the base class for Latch and GlobalData.</p><h3>Important methods:</h3><p><strong><code>Set&lt;String&gt; propertyNames()</code></strong><br/>Returns the names of all properties.</p><p><strong><code>Map&lt;String,Object&gt; getProperties()</code></strong><br/>Returns the internal HashMap from property names to property values.</p><p><strong><code>boolean hasProperty(String name)</code></strong><br/>Returns true if the specified property name exists in the container.</p><p><strong><code>void setProperty(String name, Object val)</code></strong><br/>Set a property (by name) to a specified value.</p><p><strong><code>void setClockedProperty(String name, Object val)</code></strong><br/>Set a property (by name) to a specified value. The setting is queued and does not take effect until the next clock period.</p><p><strong><code>void deleteProperty(String name)</code></strong><br/>Remove a property from the container.</p><p><strong><code>void deleteClockedProperty(String name)</code></strong><br/>Remove a property from the container. The deletion is queued and does not take effect until the next clock period.</p><p><strong><code>Integer getPropertyInteger(String name)</code></strong><br/>Returns the value of an Integer property. If the property is not an Integer, an exception is thrown.</p><p><strong><code>Integer getPropertyIntArray(String name)</code></strong><br/>Returns the value of an int array (<code>int[]</code>) property. If the property is not an int array, an exception is thrown.</p><p><strong><code>Integer getPropertyBoolean(String name)</code></strong><br/>Returns the value of a Boolean property. If the property is not a Boolean, an exception is thrown.</p><p><strong><code>Integer getPropertyBooleanArray(String name)</code></strong><br/>Returns the value of an int array (<code>boolean[]</code>) property. If the property is not a boolean array, an exception is thrown.</p><p><strong><code>Integer getPropertyString(String name)</code></strong><br/>Returns the value of a String property. If the property is not a String, an exception is thrown.</p><p><strong><code>Object getPropertyObject(Object name)</code></strong><br/>Returns the Object value of a property. This is useful for storing properties of types not explicitly supported.</p><p><strong><code>void copyPropertiesFrom(IProperties source, Set&lt;String&gt; propertiesToCopy)</code></strong><br/>Copies properties from the specified source container to this PropertiesContainer. The <code>propertiesToCopy</code> argument specifies the names of properties to copy.</p><p><strong><code>void copyAllPropertiesFrom(IProperties source)</code></strong><br/>Copy ALL properties from the specified source container.</p><h2>Globals</h2><p><code>interface IGlobals extends IProperties</code> <code>class GlobalData extends PropertiesContainer implements IGlobals</code></p><p>The Globals class is a type of PropertiesContainer tha adds program store and register file members.</p><h3>Important methods:</h3><p><strong><code>void loadProgram(InstructionSequence seq)</code></strong><br/>Load a parsed assembly language program into the container.</p><p><strong><code>InstructionBase getInstructionAt(int pc_address)</code></strong><br/>Retrieve an instruction at the specified address from the program store.</p><p><strong><code>IRegFile getRegisterFile()</code></strong><br/>Returns a reference to the register file.</p><p><strong><code>void setup()</code></strong><br/>Called automatically by the constructor, you must implement this method to pre-set properties that must already exist and set up the RegisterFile.</p><p><strong><code>void advanceClock()</code></strong><br/>Must call <code>super.advanceClock()</code> and <code>regfile.advanceClock()</code> in order to apply queued global property changes and register file updates.</p><h2>RegisterFile</h2><p><code>class RegisterFile implements IRegFile</code></p><p>Contains a specifiable number of architectural or physical registers, along with their states (validity, result of float computation). </p><p>32-bit integers and single-precision floating point values occupy the same number of bytes in memory, so the raw bits encoding floating point values are reinterpreted as integers for storage in the register file. This reinterpretation of memory bits is not the same as type casting, which attempts to convert numbers between types so that they have the same meaning. For example, the floating point number 1.0 when stored in a register is not converted to the integer value 1. It is stored as the integer 0x7F800000, which is the underlying binary representation of 1.0 in single-precision floating point.</p><h3>Important methods:</h3><p><strong><code>boolean isInvalid(int index)</code></strong><br/><strong><code>boolean isValid(int index)</code></strong><br/><strong><code>boolean isFloat(int index)</code></strong><br/>Check if a specified arch/phys register is invalid, valid, or the result of floating point computation.</p><p><strong><code>int getValue(int index)</code></strong><br/>Returns the contents of the specified register in integer form (even if the bits stored there are a float). Throws an exception if the register is not valid.</p><p><strong><code>float getValueAsFloat(int index)</code></strong><br/>Returns the contents of the specified register in float form. Throws an exception if the register is not valid or it does not contain a float value.</p><p><strong><code>void setIntValue(int index, int value)</code></strong><br/>Updates a register with a new integer value (resulting from integer computation). The update is queued so that it does not take effect until the next clock cycle. The register will also be marked as valid and not float.</p><p><strong><code>void setFloatValue(int index, int value)</code></strong><br/>Updates a register with a new float value (resulting from float computation), although the float bits encoded in an integer. The update is queued so that it does not take effect until the next clock cycle. The register will also be marked as valid and float.</p><p><strong><code>void setFloatValue(int index, float value)</code></strong><br/>Updates a register with a new float value (resulting from float computation). The raw float bits are reinterpreted in integer form. The update is queued so that it does not take effect until the next clock cycle. The register will also be marked as valid and float.</p><p><strong><code>void setValue(int index, int value, boolean is_float)</code></strong><br/>Updates a register with a new value. Whether or not the value (encoded as an int) is a reinterpreted float is specified by the <code>is_float</code> argument. The update is queued so that it does not take effect until the next clock cycle. The register will also be marked as valid and float.</p>
</body>
</html>